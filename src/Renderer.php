<?php

/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Vincent Tscherter <tscherter@karmin.ch>
 * @author Sven Strittmatter <ich@weltraumschaf.de>
 */

namespace de\weltraumschaf\ebnf;

use \DOMDocument as DOMDocument;
use \DOMElement as DOMElement;
use \RuntimeException as RuntimeException;
use \InvalidArgumentException as InvalidArgumentException;

/**
 * Renders the XML DOM syntax tree generated by the Parser} to different formats.
 *
 * Either you can choose between some image formats (png, gif, jpg) or XML. The XML
 * format is the direct syntax tree representation generated by the parser.
 */
class Renderer {
    const DEFAULT_FONT = 4;
    const DEFAULT_UNIT = 16;

    const FORMAT_PNG = "png";
    const FORMAT_JPG = "jpg";
    const FORMAT_GIF = "gif";
    const FORMAT_XML = "xml";

    /**
     * GD lib color resource for white.
     *
     * @var resource
     */
    private $white;

    /**
     * GD lib color resource for black.
     *
     * @var resource
     */
    private $black;

    /**
     * GD lib color resource for blue.
     *
     * @var resource
     */
    private $blue;

    /**
     * GD lib color resource for red.
     *
     * @var resource
     */
    private $red;

    /**
     * GD lib color resource for green.
     *
     * @var resource
     */
    private $green;

    /**
     * GD lib color resource for silver.
     *
     * @var resource
     */
    private $silver;

    /**
     * The output format.
     *
     * @var string
     */
    private $format;

    /**
     * The output file.
     *
     * @var string
     */
    private $file;

    /**
     * The syntax tree.
     *
     * @var DOMDocument
     */
    private $dom;

    /**
     * Actual GD font.
     *
     * @var int
     */
    private $font;

    /**
     * Actual scaling factor.
     *
     * @var int
     */
    private $unit;

    /**
     * Initializes the renderer with the syntax tree, format and file.
     *
     * Optional you can specify the GD lib font siye and the unit.
     *
     * @param string      $format One of the FORMAT_* constants.
     * @param string      $file   Where to store the rendered result.
     * @param DOMDocument $dom    The abstract syntax tree from the parser.
     * @param int         $font   The GD font.
     * @param int         $unit   The scale factor.
     */
    public function __construct($format, $file, DOMDocument $dom, $font = self::DEFAULT_FONT, $unit = self::DEFAULT_UNIT) {
        $this->format = (string) $format;
        $this->file   = (string) $file;
        $this->dom    = $dom;
        $this->font   = (int) $font;
        $this->unit   = (int) $unit;
    }

    /**
     * Renders ans saves the grammar into file.
     *
     * @return void
     */
    public function save() {
        if (self::FORMAT_XML === $this->format) {
            $out = $this->dom->saveXML();

            if (false === file_put_contents($this->file, $out)) {
                throw new \RuntimeException("Can't write output to '{$this->file}'!");
            }
        } else {
            $this->saveImage();
        }
    }

    /**
     * Render and saves especialy all image formats.
     *
     * @return void
     */
    private function saveImage() {
        $out = $this->renderNode($this->dom->firstChild, true);

        switch ($this->format) {
            case self::FORMAT_PNG:
                imagepng($out, $this->file);
                break;
            case self::FORMAT_JPG:
                imagejpeg($out, $this->file);
                break;
            case self::FORMAT_GIF:
                imagegif($out, $this->file);
                break;
            default:
                throw new \InvalidArgumentException("Unsupported format: '{$this->format}'!");
        }

        imagedestroy($out);
    }

    /**
     * Draws a rectangle with round corners on an image resource.
     *
     * @param resource $image Image in which the rectangle is drawed.
     * @param int      $x1    Start x coordinate.
     * @param int      $y1    Start y coordinate.
     * @param int      $x2    End x coordinat.
     * @param int      $y2    End y coordinate.
     * @param int      $r     Radius factor.
     * @param resource $color Coler resource for rectangle.
     *
     * @return void
     */
    private function rr($image, $x1, $y1, $x2, $y2, $r, $color) {
        imageline($image, $x1 + $r, $y1, $x2 - $r, $y1, $color);
        imageline($image, $x1 + $r, $y2, $x2 - $r, $y2, $color);
        imageline($image, $x1, $y1 + $r, $x1, $y2 - $r, $color);
        imageline($image, $x2, $y1 + $r, $x2, $y2 - $r, $color);
        imagearc($image, $x1 + $r, $y1 + $r, 2 * $r, 2 * $r, 180, 270, $color);
        imagearc($image, $x2 - $r, $y1 + $r, 2 * $r, 2 * $r, 270, 360, $color);
        imagearc($image, $x1 + $r, $y2 - $r, 2 * $r, 2 * $r, 90, 180, $color);
        imagearc($image, $x2 - $r, $y2 - $r, 2 * $r, 2 * $r, 0, 90, $color);
    }

    /**
     * Creates an image resource.
     *
     * @param int $width  Width in pixels.
     * @param int $height Height in pixels.
     *
     * @return resource
     */
    private function createImage($width, $height) {
        $im = imagecreatetruecolor($width, $height);
        imageantialias($im, true);
        $this->white = imagecolorallocate($im, 255, 255, 255);
        $this->black = imagecolorallocate($im, 0, 0, 0);
        $this->blue = imagecolorallocate($im, 0, 0, 255);
        $this->red = imagecolorallocate($im, 255, 0, 0);
        $this->green = imagecolorallocate($im, 0, 200, 0);
        $this->silver = imagecolorallocate($im, 127, 127, 127);
        imagefilledrectangle($im, 0, 0, $width, $height, $this->white);

        return $im;
    }

    /**
     * Draws an arrow on an given image.
     *
     * @param resource $image       Image to draw the arrow at.
     * @param int      $x           X position.
     * @param int      $y           Y position.
     * @param bool     $leftToRight If true the arrow is ->, false it is <-
     *
     * @return void
     */
    private function arrow($image, $x, $y, $leftToRight) {
        if ($leftToRight) {
            $points = array(
                $x - $this->unit,
                $y - $this->unit / 3,
                $x,
                $y,
                $x - $this->unit,
                $y + $this->unit / 3
            );
        } else {
            $points = array(
                $x,
                $y - $this->unit / 3,
                $x - $this->unit,
                $y,
                $x,
                $y + $this->unit / 3);
        }

        imagefilledpolygon($image, $points, 3, $this->black);
    }

    /**
     * Renders anny AST node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return resource
     */
    private function renderNode(DOMElement $node, $leftToRight) {
        if ($node->nodeName === Parser::NODE_TYPE_IDENTIFIER || $node->nodeName === Parser::NODE_TYPE_TERMINAL) {
            return $this->renderIdentifierOrTerminal($node);
        } else if ($node->nodeName === Parser::NODE_TYPE_OPTION || $node->nodeName === Parser::NODE_TYPE_LOOP) {
            return $this->renderOptionOrLoopNode($node, $leftToRight);
        } else if ($node->nodeName === Parser::NODE_TYPE_SEQUENCE) {
            return $this->renderSequenceNode($node, $leftToRight);
        } else if ($node->nodeName === Parser::NODE_TYPE_CHOICE) {
            return $this->renderChoiceNode($node, $leftToRight);
        } else if ($node->nodeName === Parser::NODE_TYPE_SYNTAX) {
            return $this->renderSyntaxNode($node, $leftToRight);
        }
    }

    /**
     * Renders the child nodes of an AST node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return array of resource
     */
    private function renderChilds(DOMElement $node, $leftToRight) {
        $childs = array();
        $node = $node->firstChild;

        while ($node !== null) {
            $childs[] = $this->renderNode($node, $leftToRight);
            $node = $node->nextSibling;
        }

        return $childs;
    }

    /**
     * Renders an AST syntax node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return resource
     */
    private function renderSyntaxNode(DOMElement $node, $leftToRight) {
        $title = $node->getAttribute('title');
        $meta = $node->getAttribute('meta');
        $node = $node->firstChild;
        $names = array();
        $images = array();

        while ($node != null) {
            $names[] = $node->getAttribute('name');
            $image = $this->renderNode($node->firstChild, $leftToRight);
            $images[] = $image;
            $node = $node->nextSibling;
        }

        $wn = 0;
        $wr = 0;
        $height = 5 * $this->unit;
        $imagesCnt = count($images);

        for ($i = 0; $i < $imagesCnt; $i++) {
            $wn = max($wn, imagefontwidth($this->font) * strlen($names[$i]));
            $wr = max($wr, imagesx($images[$i]));
            $height += imagesy($images[$i]) + 2 * $this->unit;
        }

        if ($title == '') {
            $height -= 2 * $this->unit;
        }

        if ($meta == '') {
            $height -= 2 * $this->unit;
        }

        $height += 10;
        $weight = max($wr + $wn + 3 * $this->unit, imagefontwidth(1) * strlen($meta) + 2 * $this->unit) + 10;
        $image = $this->createImage($weight, $height);
        $y = 2 * $this->unit;

        if ($title != '') {
            imagestring(
                $image,
                $this->font,
                $this->unit,
                (2 * $this->unit - imagefontheight($this->font)) / 2,
                $title,
                $this->green
            );
            imageline($image, 5, 2 * $this->unit, $weight - 5, 2 * $this->unit, $this->green);
            $y += 2 * $this->unit;
        }

        $imagesCnt = count($images);

        for ($i = 0; $i < $imagesCnt; $i++) {
            imagestring(
                $image,
                $this->font,
                $this->unit,
                $y - $this->unit + (2 * $this->unit - imagefontheight($this->font)) / 2,
                $names[$i],
                $this->red
            );
            imagecopy(
                $image,
                $images[$i],
                $wn + 2 * $this->unit,
                $y,
                0,
                0,
                imagesx($images[$i]),
                imagesy($images[$i])
            );
            imageline(
                $image,
                $this->unit,
                $y + $this->unit,
                $wn + 2 * $this->unit,
                $y + $this->unit,
                $this->black
            );
            imageline(
                $image,
                $wn + 2 * $this->unit + imagesx($images[$i]) - 1,
                $y + $this->unit,
                $weight - $this->unit,
                $y + $this->unit,
                $this->black
            );
            imageline(
                $image,
                $weight - $this->unit,
                $y + $this->unit / 2,
                $weight - $this->unit,
                $y + 1.5 * $this->unit,
                $this->black
            );
            $y += 2 * $this->unit + imagesy($images[$i]);
        }

        imagestring(
            $image,
            1,
            $this->unit,
            $height - 2 * $this->unit + (2 * $this->unit - imagefontheight(1)) / 2,
            $meta,
            $this->silver
        );
        $this->rr($image, 5, 5, $weight - 5, $height - 5, $this->unit / 2, $this->green);

        return $image;
    }

    /**
     * Renders an AST choice node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return resource
     */
    private function renderChoiceNode(DOMElement $node, $leftToRight) {
        $inner = $this->renderChilds($node, $leftToRight);
        $height = (count($inner) - 1) * $this->unit;
        $width = 0;
        $innerCnt = count($inner);

        for ($i = 0; $i < $innerCnt; $i++) {
            $height += imagesy($inner[$i]);
            $width = max($width, imagesx($inner[$i]));
        }

        $width += 6 * $this->unit;
        $image = $this->createImage($width, $height);
        $y = 0;
        imageline($image, 0, $this->unit, $this->unit, $this->unit, $this->black);
        imageline($image, $width - $this->unit, $this->unit, $width, $this->unit, $this->black);

        for ($i = 0; $i < $innerCnt; $i++) {
            imageline($image, $this->unit, $y + $this->unit, $width - $this->unit, $y + $this->unit, $this->black);
            imagecopy($image, $inner[$i], 3 * $this->unit, $y, 0, 0, imagesx($inner[$i]), imagesy($inner[$i]));
            $this->arrow($image, 3 * $this->unit, $y + $this->unit, $leftToRight);
            $this->arrow($image, $width - 2 * $this->unit, $y + $this->unit, $leftToRight);
            $top = $y + $this->unit;
            $y += imagesy($inner[$i]) + $this->unit;
        }

        imageline($image, $this->unit, $this->unit, $this->unit, $top, $this->black);
        imageline($image, $width - $this->unit, $this->unit, $width - $this->unit, $top, $this->black);

        return $image;
    }

    /**
     * Renders an AST syntax node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return resource
     */
    private function renderSequenceNode(DOMElement $node, $leftToRight) {
        $inner = $this->renderChilds($node, $leftToRight);

        if (!$leftToRight) {
            $inner = array_reverse($inner);
        }

        $width = count($inner) * $this->unit - $this->unit;
        $height = 0;
        $innerCnt = count($inner);

        for ($i = 0; $i < $innerCnt; $i++) {
            $width += imagesx($inner[$i]);
            $height = max($height, imagesy($inner[$i]));
        }

        $image = $this->createImage($width, $height);
        imagecopy($image, $inner[0], 0, 0, 0, 0, imagesx($inner[0]), imagesy($inner[0]));
        $x = imagesx($inner[0]) + $this->unit;

        for ($i = 1; $i < $innerCnt; $i++) {
            imageline($image, $x - $this->unit - 1, $this->unit, $x, $this->unit, $this->black);
            $this->arrow($image, $x, $this->unit, $leftToRight);
            imagecopy($image, $inner[$i], $x, 0, 0, 0, imagesx($inner[$i]), imagesy($inner[$i]));
            $x += imagesx($inner[$i]) + $this->unit;
        }

        return $image;
    }

    /**
     * Renders an AST option or loop node.
     *
     * @param DOMElement $node        The AST node.
     * @param bool       $leftToRight Railroad direction used for arrows.
     *
     * @return resource
     */
    private function renderOptionOrLoopNode(DOMElement $node, $leftToRight) {
        if ($node->nodeName === Parser::NODE_TYPE_LOOP) {
            $leftToRight = !$leftToRight;
        }

        $inner = $this->renderNode($node->firstChild, $leftToRight);
        $width = imagesx($inner) + 6 * $this->unit;
        $height = imagesy($inner) + 2 * $this->unit;
        $image = $this->createImage($width, $height);
        imagecopy($image, $inner, 3 * $this->unit, 2 * $this->unit, 0, 0, imagesx($inner), imagesy($inner));
        imageline($image, 0, $this->unit, $width, $this->unit, $this->black);

        if ($node->nodeName === Parser::NODE_TYPE_LOOP) {
            $this->arrow($image, $width / 2 + $this->unit / 2, $this->unit, !$leftToRight);
        } else {
            $this->arrow($image, $width / 2 + $this->unit / 2, $this->unit, $leftToRight);
        }

        $this->arrow($image, 3 * $this->unit, 3 * $this->unit, $leftToRight);
        $this->arrow($image, $width - 2 * $this->unit, 3 * $this->unit, $leftToRight);
        imageline($image, $this->unit, $this->unit, $this->unit, 3 * $this->unit, $this->black);
        imageline($image, $this->unit, 3 * $this->unit, 2 * $this->unit, 3 * $this->unit, $this->black);
        imageline($image, $width - $this->unit, $this->unit, $width - $this->unit, 3 * $this->unit, $this->black);
        imageline($image, $width - 3 * $this->unit - 1, 3 * $this->unit, $width - $this->unit, 3 * $this->unit, $this->black);
        return $image;
    }

    /**
     * Renders an AST identifier or terminal node.
     *
     * @param DOMElement $node The AST node.
     *
     * @return resource
     */
    private function renderIdentifierOrTerminal($node) {
        $text = $node->getAttribute('value');
        $width = imagefontwidth($this->font) * (strlen($text)) + 4 * $this->unit;
        $height = 2 * $this->unit;
        $image = $this->createImage($width, $height);

        if ($node->nodeName !== Parser::NODE_TYPE_TERMINAL) {
            imagerectangle($image, $this->unit, 0, $width - $this->unit - 1, $height - 1, $this->black);
            imagestring($image, $this->font, 2 * $this->unit, ($height - imagefontheight($this->font)) / 2, $text, $this->red);
        } else {
            if ($text !== "...") {
                $this->rr($image, $this->unit, 0, $width - $this->unit - 1, $height - 1, $this->unit / 2, $this->black);
            }

            if ($text !== "...") {
                $color = $this->blue;
            } else {
                $color = $this->black;
            }

            imagestring($image, $this->font, 2 * $this->unit, ($height - imagefontheight($this->font)) / 2, $text, $color);
        }

        imageline($image, 0, $this->unit, $this->unit, $this->unit, $this->black);
        imageline($image, $width - $this->unit, $this->unit, $width + 1, $this->unit, $this->black);
        return $image;
    }

}
